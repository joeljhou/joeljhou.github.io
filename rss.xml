<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://www.geekyspace.cn/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://www.geekyspace.cn/rss.xml" rel="self" type="application/rss+xml"/>
    <title>极客空间</title>
    <link>https://www.geekyspace.cn/</link>
    <description>vuepress-theme-hope 的博客搭建</description>
    <language>zh-CN</language>
    <pubDate>Thu, 11 Jan 2024 07:05:18 GMT</pubDate>
    <lastBuildDate>Thu, 11 Jan 2024 07:05:18 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>Java</category>
    <category>程序人生</category>
    <item>
      <title>Java 17 新特性：switch的模式匹配（Preview）</title>
      <link>https://www.geekyspace.cn/java-features/Java17/jep406-pattern-matching-for-switch-preview.html</link>
      <guid>https://www.geekyspace.cn/java-features/Java17/jep406-pattern-matching-for-switch-preview.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 17 新特性：switch的模式匹配（Preview）</source>
      <description>Java 17 新特性：switch的模式匹配（Preview）</description>
      <category>Java</category>
      <pubDate>Sat, 30 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java 17 新特性：switch的模式匹配（Preview）</h1>
]]></content:encoded>
    </item>
    <item>
      <title>Java 17 新特性：密封类</title>
      <link>https://www.geekyspace.cn/java-features/Java17/jep409-sealed-classes.html</link>
      <guid>https://www.geekyspace.cn/java-features/Java17/jep409-sealed-classes.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 17 新特性：密封类</source>
      <description>Java 17 新特性：密封类</description>
      <category>Java</category>
      <pubDate>Sun, 31 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java 17 新特性：密封类</h1>
]]></content:encoded>
    </item>
    <item>
      <title>Java 16 新特性：instanceof增强</title>
      <link>https://www.geekyspace.cn/java-features/Java16/jep394-pattern-matching-for-instanceof.html</link>
      <guid>https://www.geekyspace.cn/java-features/Java16/jep394-pattern-matching-for-instanceof.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 16 新特性：instanceof增强</source>
      <description>Java 16 新特性：instanceof增强 Java 16 引入了 instanceof 的增强语法，用于更简便地判断对象是否是某个类的实例并进行相应的局部类型转换。 instanceof 基础用法 if (obj instanceof String) { String someString = (String) obj; // 强制类型转换 // ... }</description>
      <category>Java</category>
      <pubDate>Thu, 28 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java 16 新特性：instanceof增强</h1>
<p>Java 16 引入了 <code>instanceof</code> 的增强语法，用于更简便地判断对象是否是某个类的实例并进行相应的<strong>局部类型转换</strong>。</p>
<h2> instanceof 基础用法</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个<strong>强制转换</strong>通常是在 <code>instanceof</code> 检查之后 的第一件事，所以为什么不围绕它优化一下语法呢？</p>
<h2> instanceof 增强用法</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol>
<li>若 <code>instanceof</code> 检查成功，将自动将变量转换为指定类型</li>
<li>定义的变量实质上是一个<strong>局部变量</strong>，只在if语句的范围内可见</li>
</ol>
<h2> 常见用法建议</h2>
<p>不仅如此！使用模式匹配，我们可以更灵活地应用条件测试。</p>
<ul>
<li>
<p>利用已定义的 obj，在不需要额外嵌套的情况下判断字符串是否以“Awesome”开头</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>甚至在 equals 方法中，代码会更加简洁</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<p>多么不同！现在代码简洁而直观。</p>
<h2> 发展脉络</h2>
<p>该功能经历了2个预览版本（JDK 14中的JEP 305、JDK 15中的JEP 375），最终定稿于JDK 16中的JEP 394。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 16 新特性：record类</title>
      <link>https://www.geekyspace.cn/java-features/Java16/jep395-records.html</link>
      <guid>https://www.geekyspace.cn/java-features/Java16/jep395-records.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 16 新特性：record类</source>
      <description>Java 16 新特性：record类 Java 16引入的record类是一种用于简化不可变数据管理的特殊类。 它通过紧凑的语法提供了对不可变数据的支持，并自动生成常见的方法， 如equals()、hashCode()和toString()等，从而减少了开发者的样板代码。 传统Java Bean问题 在处理不可变数据时，传统的Java Bean存在“繁琐”和“冗长”的问题。 为了管理少量值的不可变数据，开发者需要编写大量低价值、重复且容易出错的代码， 包括构造函数、访问器(getter/setter)、equals、hashCode、toString等。</description>
      <category>Java</category>
      <pubDate>Fri, 29 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java 16 新特性：record类</h1>
<p>Java 16引入的<code>record</code>类是一种用于简化不可变数据管理的特殊类。
它通过紧凑的语法提供了对不可变数据的支持，并自动生成常见的方法，
如<code>equals()</code>、<code>hashCode()</code>和<code>toString()</code>等，从而减少了开发者的样板代码。</p>
<h2> 传统Java Bean问题</h2>
<p>在处理不可变数据时，传统的Java Bean存在“<mark>繁琐</mark>”和“<mark>冗长</mark>”的问题。
为了管理少量值的不可变数据，开发者需要编写大量低价值、重复且容易出错的代码，
包括<code>构造函数</code>、<code>访问器(getter/setter)</code>、<code>equals</code>、<code>hashCode</code>、<code>toString</code>等。</p>
<p>例如，用于携带x和y坐标的类通常会演变成以下繁琐形式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 引入record类</h2>
<p><strong>语法如下</strong>：使用 <code>record</code><mark>关键字</mark>，指定<mark>类名称</mark>为 Point，定义<mark>参数列表</mark> x 和 y 作为组件</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>record申明的类，具备这些特点：</p>
<ol>
<li>它是一个<code>final</code>类</li>
<li>自动实现<code>equals</code>、<code>hashCode</code>、<code>toString</code>函数</li>
<li>成员变量均为<code>public</code>属性</li>
</ol>
<p>所以，对于之前写的Point类，它等价于一个这样的类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过使用record类，你可以更专注于业务逻辑而不是样板代码，提高了代码的可读性和可维护性。</p>
<h2> 显示声明紧凑构造函数</h2>
<p>未显式声明构造函数时，系统会自动生成包含所有成员变量的隐式构造函数。
当显式声明紧凑构造函数可以<mark>省略形式参数列表</mark>、编译后在构造函数的末尾<mark>自动分配</mark>给相应的形式参数（this.x = x;）。</p>
<ul>
<li>
<p><strong>验证参数</strong>的紧凑构造函数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>规范</strong>的紧凑构造函数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个声明等同于传统的构造函数形式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>记录类<strong>语义一致性</strong></p>
<p>例如，考虑以下方式声明的记录类R：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果通过以下方式复制R的实例r1：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>则假设 r1 不是空引用，表达式 r1.equals(r2) 总是为 true。
这是因为记录类的隐式声明的 equals 方法保证了相同字段值的两个记录实例相等。</p>
<blockquote>
<p>Tips: 程序员需要谨慎确保显式声明的方法维持语义一致性</p>
</blockquote>
</li>
<li>
<p>避免不良风格的代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是一个不良风格的代码，违反了语义一致性的原则，访问器<code>x()</code>,<code>y()</code>方法调整类实例的状态；
<strong>改进建议</strong>， 如果需要限制坐标值的范围，应该在构造函数或其他明确的位置处理。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h2> 发展脉络</h2>
<p><code>record</code> 类最初在JDK 14预览版(JEP 359)提出，随后在JDK 15预览版(JEP 384)再次推出。
最终，它在JDK 16中(JEP 395)正式发布，成为Java语言的一项重要特性。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 15 新特性：隐藏类</title>
      <link>https://www.geekyspace.cn/java-features/Java15/jep371-hidden-classes.html</link>
      <guid>https://www.geekyspace.cn/java-features/Java15/jep371-hidden-classes.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 15 新特性：隐藏类</source>
      <description>Java 15 新特性：隐藏类 Hidden Classes 提供了一种在运行时生成类的机制，在编译时未知，并且不能直接在源代码中引用， 需要通过反射间接使用它们，隐藏类是为框架设计的，具有以下特性： 动态生成内部类：隐藏类天生为框架设计，在运行时生成内部类 反射访问限制：隐藏类只能通过反射访问，不能直接被其他类的字节码访问 独立加载和卸载：隐藏类可以独立于其他类加载和卸载 框架扩展性：适用于需要在运行时生成类的框架，提高语言的灵活性和效率</description>
      <category>Java</category>
      <pubDate>Tue, 26 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java 15 新特性：隐藏类</h1>
<p>Hidden Classes 提供了一种在运行时生成类的机制，在编译时未知，并且不能直接在源代码中引用，
需要通过反射间接使用它们，隐藏类是为框架设计的，具有以下特性：</p>
<ul>
<li><strong>动态生成内部类</strong>：隐藏类天生为框架设计，在运行时生成内部类</li>
<li><strong>反射访问限制</strong>：隐藏类只能通过反射访问，不能直接被其他类的字节码访问</li>
<li><strong>独立加载和卸载</strong>：隐藏类可以独立于其他类加载和卸载</li>
<li><strong>框架扩展性</strong>：适用于需要在运行时生成类的框架，提高语言的灵活性和效率</li>
</ul>
<h2> 原理</h2>
<h2> 框架中应用</h2>
<p><a href="https://bugs.openjdk.org/browse/JDK-8220607" target="_blank" rel="noopener noreferrer">https://bugs.openjdk.org/browse/JDK-8220607</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 15 新特性：文本块</title>
      <link>https://www.geekyspace.cn/java-features/Java15/jep378-text-blocks.html</link>
      <guid>https://www.geekyspace.cn/java-features/Java15/jep378-text-blocks.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 15 新特性：文本块</source>
      <description>Java 15 新特性：文本块 Java 15（JEP 378）引入了文本块（Text Blocks）这一新特性，旨在简化多行字符串的表示，提高代码可读性，并减少在字符串中使用转义符的需求。 文本块通过引入三个双引号的胖分隔符（&amp;quot;&amp;quot;&amp;quot;）来实现，同时支持转义序列，为开发人员提供更直观、易读的字符串处理方式。 快速上手 HTML示例 // 使用“一维”字符串文字 String html = &amp;quot;&amp;lt;html&amp;gt;\n&amp;quot; + &amp;quot; &amp;lt;body&amp;gt;\n&amp;quot; + &amp;quot; &amp;lt;p&amp;gt;Hello, world&amp;lt;/p&amp;gt;\n&amp;quot; + &amp;quot; &amp;lt;/body&amp;gt;\n&amp;quot; + &amp;quot;&amp;lt;/html&amp;gt;\n&amp;quot;; // 使用“二维”文本块 String html = &amp;quot;&amp;quot;&amp;quot; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;p&amp;gt;Hello, world&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; &amp;quot;&amp;quot;&amp;quot;;</description>
      <category>Java</category>
      <pubDate>Wed, 27 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java 15 新特性：文本块</h1>
<p>Java 15（JEP 378）引入了文本块（Text Blocks）这一新特性，旨在简化多行字符串的表示，提高代码可读性，并减少在字符串中使用转义符的需求。
文本块通过引入三个双引号的<strong>胖分隔符</strong>（<code>"""</code>）来实现，同时支持转义序列，为开发人员提供更直观、易读的字符串处理方式。</p>
<h2> 快速上手</h2>
<p><strong>HTML示例</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>SQL示例</strong></p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Polyglot语言示例</strong></p>
<div class="language-polyglot line-numbers-mode" data-ext="polyglot"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 编译时处理</h2>
<p>文本块是String类型的常量表达式，类似于字符串字面量。然而，与字符串字面值不同，文本块的内容在编译时经历三个步骤的处理：<mark>行终止符的规范化</mark>、<mark>附带白色空间的移除</mark>和<mark>解释转义序列</mark>：</p>
<ol>
<li>转换内容的行终止符
<ul>
<li>行终止符从CR（\u000D）和CRLF（\u000D\u000A）规范化为<code>LF（\u000A）</code></li>
</ul>
</li>
<li>删除内容周围附带的白色空间（用于匹配Java源代码的缩进）</li>
<li>解释内容中的转义序列，执行解释作为最后一步开发人员可以编写转义序列，如\n，而不会被前面的步骤修改或删除</li>
</ol>
<p>处理后的内容以<code>CONSTANT_String_info</code>形式记录在<strong>类文件的常量池</strong>中，运行时，文本块被计算为String的实例。</p>
<h2> 新增转义序列</h2>
<p>为了更精细地控制<mark>换行符</mark>和<mark>空格</mark>的处理，引入了两个新的转义序列：\ &lt;line-terminator&gt; 和 \s。</p>
<h3> 换行符 \ &lt;line-terminator&gt;</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>Tips： 因为字符和传统字符串不允许嵌入换行符，所以\ &lt;line-terminator&gt; 转义序列只适用于文本块</p>
</blockquote>
<h3> 单个空格 \s</h3>
<p>新的 \s 转义序列简单地转换为单个空格（\u0020）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>转义序列直到去除无意义的空格后才被解释，\s 可以作为栅栏，防止尾随空格被去除。
在这个示例中，每行末尾使用 \s 可以确保每行长度恰好为六个字符。</p>
<h2> 文本块连接</h2>
<p>文本块的连接是引入的一个方便的特性，使得字符串的拼接变得更加简洁。
在连接时，相邻的文本块将自动合并，无需显式使用加号连接操作符。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，两个相邻的文本块会自动连接，形成一个整体的字符串。
这种自动连接的特性让代码更加清晰，减少了冗余的拼接操作。</p>
<h2> 文本块新方法</h2>
<p>文本块引入了一些新方法，以便更方便地处理多行字符串：</p>
<ul>
<li><code>String::stripIndent()</code>：去除多行字符串的前导空格</li>
<li><code>String::translateEscapes()</code>：转义多行字符串中的转义字符</li>
<li><code>String::formatted()</code>：在文本块中使用占位符进行值替换</li>
<li><code>String::lines()：</code>：将多行字符串拆分为行的流，方便逐行处理。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java 14 新特性：switch表达式增强</title>
      <link>https://www.geekyspace.cn/java-features/Java14/jep361-switch-expressions.html</link>
      <guid>https://www.geekyspace.cn/java-features/Java14/jep361-switch-expressions.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 14 新特性：switch表达式增强</source>
      <description>Java 14 新特性：switch表达式增强 Java 14（JEP 361）引入了 switch 表达式的新特性，其中包括了 &amp;quot;箭头标签（case ... -&amp;gt;）&amp;quot; 和 yield 语句的增强， 同时支持 Lambda 语法，使得代码更加灵活、简洁，并为未来的模式匹配（JEP 305）特性做好了准备。 传统的switch语句 首先，让我们回顾一下传统的switch语句，它们在处理多个条件时可能显得有些冗长：</description>
      <category>Java</category>
      <pubDate>Mon, 25 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java 14 新特性：switch表达式增强</h1>
<p>Java 14（JEP 361）引入了 switch 表达式的新特性，其中包括了 "箭头标签（<code>case ... -&gt;</code>）" 和 <code>yield</code> 语句的增强，
同时支持 <code>Lambda</code> 语法，使得代码更加灵活、简洁，并为未来的<strong>模式匹配</strong>（JEP 305）特性做好了准备。</p>
<h2> 传统的switch语句</h2>
<p>首先，让我们回顾一下传统的switch语句，它们在处理多个条件时可能显得有些冗长：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>传统的 switch 语句存在以下问题：</p>
<ol>
<li>设计受到C和C++等低级语言的影响，且默认支持fall through语义</li>
<li>过多的<code>break</code>语句使得代码显得冗长</li>
</ol>
<h2> switch表达式增强</h2>
<h3> 箭头标签（case L -&gt;）</h3>
<ol>
<li>引入了一种新的开关标签"<code>case L -&gt;</code>"，用于表示只有一个分支的情况</li>
<li>允许每种情况下有多个常量，用逗号分隔</li>
<li>标签右侧的代码仅限于表达式、块或抛出异常throw语句</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 局部变量独立作用域</h3>
<p>在 Java 14 中，允许在每个分支中声明局部变量，避免块中变量命名冲突和误用。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> switch表达式</h3>
<p>Switch 表达式被引入，允许将 <code>switch</code> 语句用作表达式，通过 <code>Lambda</code> 语法，根据输入值返回不同的结果。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Switch表达式的常见形式如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>Switch表达式是多态表达式（poly expression）。</p>
<p>多态性是指在编译时不确定具体类型，而在运行时确定类型的特性。</p>
</blockquote>
<h3> yield语句返回值</h3>
<p>允许在switch表达式中使用<code>yield</code>语句，而不是使用<code>break</code>语句，用于返回一个值，结束switch表达式的执行。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 发展脉络</h2>
<p>追溯JEP 361的发展历程：从JDK 12预览版(JEP 325)到JDK 13预览版(JEP 354)，
虽然部分功能在早期版本中已经出现，但建议在 JDK 14 及以后的版本中使用，以获得更好的稳定性和支持。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 11 新特性 ：移除JavaEE和CORBA模块以及JavaFX</title>
      <link>https://www.geekyspace.cn/java-features/Java11/jep320-remove-JavaEE-CORBA.html</link>
      <guid>https://www.geekyspace.cn/java-features/Java11/jep320-remove-JavaEE-CORBA.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 11 新特性 ：移除JavaEE和CORBA模块以及JavaFX</source>
      <description>Java 11 新特性 ：移除JavaEE和CORBA模块以及JavaFX Java 11 中移除了 Java EE 和 CORBA 模块，同时 JavaFX 也被剥离，但仍可作为独立模块使用。 Java9 弃用过程 在 Java 9 中，Java EE 和 CORBA 模块被标记为 @Deprecated，为开发者提供了适应期。 Java11 彻底删除 Java 11 完全删除了以下九个模块：</description>
      <category>Java</category>
      <pubDate>Sun, 24 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java 11 新特性 ：移除JavaEE和CORBA模块以及JavaFX</h1>
<p>Java 11 中移除了 <code>Java EE</code> 和 <code>CORBA</code> 模块，同时 <code>JavaFX</code> 也被剥离，但仍可作为独立模块使用。</p>
<h2> Java9 弃用过程</h2>
<p>在 Java 9 中，<code>Java EE</code> 和 <code>CORBA</code> 模块被标记为 @Deprecated，为开发者提供了适应期。</p>
<h2> Java11 彻底删除</h2>
<p>Java 11 完全删除了以下九个模块：</p>
<ul>
<li>java.xml.ws（包含 JAX-WS、SAAJ 和 Web 服务元数据）</li>
<li>java.xml.bind（JAXB）</li>
<li>java.activation(JAF)</li>
<li>java.xml.ws.annotation（常用注解）</li>
<li>java.corba（CORBA）</li>
<li>java.transaction(JTA)</li>
<li>java.se.ee (以上6个模块的聚合模块)</li>
<li>jdk.xml.ws (JAX-WS 工具)</li>
<li>jdk.xml.bind (JAXB 工具)</li>
</ul>
<p>删除后的影响：</p>
<ul>
<li>源代码从 OpenJDK 存储库中删除</li>
<li>在 JDK 运行时映像中将不包含这些类</li>
<li>相关工具将不再可用:
<ul>
<li>wsgen and wsimport (来自 jdk.xml.ws)</li>
<li>schemagen and xjc (来自 jdk.xml.bind)</li>
<li>idlj, orbd, servertool, and tnamesrv (来自 java.corba)</li>
</ul>
</li>
<li>JNDI CosNaming 提供者 (来自 java.corba) 将不再可用</li>
<li>不再有命令行标志能够启用它们，就像 JDK 9 上的 --add-modules 一样</li>
</ul>
<h2> JavaFX 移除</h2>
<p><code>JavaFX</code> 在 Java 11 中被移除，但仍可以作为独立模块使用。
开发者需要额外的配置和依赖，以在项目中继续使用 JavaFX 技术。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 10 新特性：局部变量类型推断</title>
      <link>https://www.geekyspace.cn/java-features/Java10/jep286-local-variable-type-inference.html</link>
      <guid>https://www.geekyspace.cn/java-features/Java10/jep286-local-variable-type-inference.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 10 新特性：局部变量类型推断</source>
      <description>Java 10 新特性：局部变量类型推断 Java 10 引入了一项新的语言特性，即局部变量类型推断（Local-Variable Type Inference）， 它允许在局部变量声明时，根据变量的初始值，推断出变量的数据类型。 语法 局部变量类型推断的语法非常简单，只需要将 var 关键字作为局部变量的类型即可。 var list = new ArrayList&amp;lt;String&amp;gt;(); // 自动推断 ArrayList&amp;lt;String&amp;gt; var stream = list.stream(); // 自动推断 Stream&amp;lt;String&amp;gt;</description>
      <category>Java</category>
      <pubDate>Sat, 23 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java 10 新特性：局部变量类型推断</h1>
<p>Java 10 引入了一项新的语言特性，即局部变量类型推断（Local-Variable Type Inference），
它允许在局部变量声明时，根据变量的初始值，推断出变量的数据类型。</p>
<h2> 语法</h2>
<p>局部变量类型推断的语法非常简单，只需要将 <code>var</code> 关键字作为局部变量的类型即可。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 示例</h2>
<p>相比传统的方式和 Java 7 的钻石操作符（Diamond Operator），Java 10 的局部变量类型推断使得代码更加精炼：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在使用 var 进行局部变量类型推断时，需要注意以下几点：</p>
<ol>
<li>必须在声明的同时进行初始化</li>
<li>仅限于局部变量，不能用于定义成员变量、方法参数和返回类型</li>
<li>每次只能定义一个变量，不能复合声明多个变量</li>
</ol>
<p>通过使用局部变量类型推断，我们能够在不失代码可读性的前提下，减少了冗余的类型声明，使得代码更加简洁清晰。
这一特性尤其在Lambda表达式、集合初始化等场景下表现突出，提高了代码的书写效率。
在实际项目中，合理运用局部变量类型推断，将有助于代码的维护和阅读。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 9-21：前沿特性解读系列（持续连载）</title>
      <link>https://www.geekyspace.cn/java-features/</link>
      <guid>https://www.geekyspace.cn/java-features/</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 9-21：前沿特性解读系列（持续连载）</source>
      <description>Java 9-21：前沿特性解读系列（持续连载），截至2023年9月中旬，Java已达到第21版本。 尽管如此，众多开发者仍停滞在Java 8的认知水平。为填补这一差距，我们推出专栏，聚焦分享最新Java知识。</description>
      <category>Java</category>
      <pubDate>Wed, 20 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>为了帮助大家跟上最新的技术潮流，计划启动一个专栏，重点分享Java领域的前沿知识。
这个专栏将详细解读从<strong>Java 9 - 最新版本</strong>的各种有趣的新特性。
会持续不断地发布相关内容，希望大家能够关注并收藏起来，跟随我们一起深入了解Java的最新进展！</p>
<p>详细了解Java Enhancement Proposals（JEPs）及其最新动态， 🚀 访问官方网站：<a href="https://openjdk.java.net/jeps/" target="_blank" rel="noopener noreferrer">OpenJDK JEPs</a></p>
<h2> Java 23(in development)</h2>
<h2> Java 22(in development)</h2>
<h2> Java 21(GA 2023/09/19)</h2>
<ul>
<li>430:    String Templates (Preview)</li>
<li>431:    Sequenced Collections</li>
<li>439:    Generational ZGC</li>
<li>440:    Record Patterns</li>
<li>441:    Pattern Matching for switch</li>
<li>442:    Foreign Function &amp; Memory API (Third Preview)</li>
<li>443:    Unnamed Patterns and Variables (Preview)</li>
<li>444:    Virtual Threads</li>
<li>445:    Unnamed Classes and Instance Main Methods (Preview)</li>
<li>446:    Scoped Values (Preview)</li>
<li>448:    Vector API (Sixth Incubator)</li>
<li>449:    Deprecate the Windows 32-bit x86 Port for Removal</li>
<li>451:    Prepare to Disallow the Dynamic Loading of Agents</li>
<li>452:    Key Encapsulation Mechanism API</li>
<li>453:    Structured Concurrency (Preview)</li>
</ul>
<h2> Java 20(GA 2023/03/21)</h2>
<ul>
<li>429:    Scoped Values (Incubator)</li>
<li>432:    Record Patterns (Second Preview)</li>
<li>433:    Pattern Matching for switch (Fourth Preview)</li>
<li>434:    Foreign Function &amp; Memory API (Second Preview)</li>
<li>436:    Virtual Threads (Second Preview)</li>
<li>437:    Structured Concurrency (Second Incubator)</li>
<li>438:    Vector API (Fifth Incubator)</li>
</ul>
<h2> Java 19(GA 2022/09/20)</h2>
<ul>
<li>405:    Record Patterns (Preview)</li>
<li>422:    Linux/RISC-V Port</li>
<li>424:    Foreign Function &amp; Memory API (Preview)</li>
<li>425:    Virtual Threads (Preview)</li>
<li>426:    Vector API (Fourth Incubator)</li>
<li>427:    Pattern Matching for switch (Third Preview)</li>
<li>428:    Structured Concurrency (Incubator)</li>
</ul>
<h2> Java 18(GA 2022/03/22)</h2>
<ul>
<li>400:    UTF-8 by Default</li>
<li>408:    Simple Web Server</li>
<li>413:    Code Snippets in Java API Documentation</li>
<li>416:    Reimplement Core Reflection with Method Handles</li>
<li>417:    Vector API (Third Incubator)</li>
<li>418:    Internet-Address Resolution SPI</li>
<li>419:    Foreign Function &amp; Memory API (Second Incubator)</li>
<li>420:    Pattern Matching for switch (Second Preview)</li>
<li>421:    Deprecate Finalization for Removal</li>
</ul>
<h2> Java 17(GA 2021/09/14)</h2>
<ul>
<li>306:    Restore Always-Strict Floating-Point Semantics</li>
<li>356:    Enhanced Pseudo-Random Number Generators</li>
<li>382:    New macOS Rendering Pipeline</li>
<li>391:    macOS/AArch64 Port</li>
<li>398:    Deprecate the Applet API for Removal</li>
<li>403:    Strongly Encapsulate JDK Internals</li>
<li><a href="java17/jep406-pattern-matching-for-switch-preview">406:    Pattern Matching for switch (Preview)</a></li>
<li>407:    Remove RMI Activation</li>
<li><a href="java17/jep409-sealed-classes">409:    Sealed Classes</a></li>
<li>410:    Remove the Experimental AOT and JIT Compiler</li>
<li>411:    Deprecate the Security Manager for Removal</li>
<li>412:    Foreign Function &amp; Memory API (Incubator)</li>
<li>414:    Vector API (Second Incubator)</li>
<li>415:    Context-Specific Deserialization Filters</li>
</ul>
<h2> Java 16(GA 2021/03/16)</h2>
<ul>
<li>338:    Vector API (Incubator)</li>
<li>347:    Enable C++14 Language Features</li>
<li>357:    Migrate from Mercurial to Git</li>
<li>369:    Migrate to GitHub</li>
<li>376:    ZGC: Concurrent Thread-Stack Processing</li>
<li>380:    Unix-Domain Socket Channels</li>
<li>386:    Alpine Linux Port</li>
<li>387:    Elastic Metaspace</li>
<li>388:    Windows/AArch64 Port</li>
<li>389:    Foreign Linker API (Incubator)</li>
<li>390:    Warnings for Value-Based Classes</li>
<li>392:    Packaging Tool</li>
<li>393:    Foreign-Memory Access API (Third Incubator)</li>
<li><a href="java16/jep394-pattern-matching-for-instanceof">394:    Pattern Matching for instanceof</a></li>
<li><a href="java16/jep395-records">395:    Records</a></li>
<li>396:    Strongly Encapsulate JDK Internals by Default</li>
<li>397:    Sealed Classes (Second Preview)</li>
</ul>
<h2> Java 15(GA 2020/09/15)</h2>
<ul>
<li>339:    Edwards-Curve Digital Signature Algorithm (EdDSA)</li>
<li>360:    Sealed Classes (Preview)</li>
<li><a href="java15/jep371-hidden-classes">371:    Hidden Classes</a></li>
<li>372:    Remove the Nashorn JavaScript Engine</li>
<li>373:    Reimplement the Legacy DatagramSocket API</li>
<li>374:    Disable and Deprecate Biased Locking</li>
<li>375:    Pattern Matching for instanceof (Second Preview)</li>
<li>377:    ZGC: A Scalable Low-Latency Garbage Collector</li>
<li><a href="java15/jep378-text-blocks">378:    Text Blocks</a></li>
<li>379:    Shenandoah: A Low-Pause-Time Garbage Collector</li>
<li>381:    Remove the Solaris and SPARC Ports</li>
<li>383:    Foreign-Memory Access API (Second Incubator)</li>
<li>384:    Records (Second Preview)</li>
<li>385:    Deprecate RMI Activation for Removal</li>
</ul>
<h2> Java 14(GA 2020/03/17)</h2>
<ul>
<li>305:    Pattern Matching for instanceof (Preview)</li>
<li>343:    Packaging Tool (Incubator)</li>
<li>345:    NUMA-Aware Memory Allocation for G1</li>
<li>349:    JFR Event Streaming</li>
<li>352:    Non-Volatile Mapped Byte Buffers</li>
<li>358:    Helpful NullPointerExceptions</li>
<li>359:    Records (Preview)</li>
<li><a href="java14/jep361-switch-expressions">361:    Switch Expressions (Standard)</a></li>
<li>362:    Deprecate the Solaris and SPARC Ports</li>
<li>363:    Remove the Concurrent Mark Sweep (CMS) Garbage Collector</li>
<li>364:    ZGC on macOS</li>
<li>365:    ZGC on Windows</li>
<li>366:    Deprecate the ParallelScavenge + SerialOld GC Combination</li>
<li>367:    Remove the Pack200 Tools and API</li>
<li>368:    Text Blocks (Second Preview)</li>
<li>370:    Foreign-Memory Access API (Incubator)</li>
</ul>
<h2> Java 13(GA 2019/09/17)</h2>
<ul>
<li>350: Dynamic CDS Archives</li>
<li>351: ZGC: Uncommit Unused Memory</li>
<li>353: Reimplement the Legacy Socket API</li>
<li>354: Switch Expressions (Preview)</li>
<li>355: Text Blocks (Preview)</li>
</ul>
<h2> Java 12(GA 2019/03/19)</h2>
<ul>
<li>189: Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)</li>
<li>230: Microbenchmark Suite</li>
<li>325: Switch Expressions (Preview)</li>
<li>334: JVM Constants API</li>
<li>340: One AArch64 Port, Not Two</li>
<li>341: Default CDS Archives</li>
<li>344: Abortable Mixed Collections for G1</li>
<li>346: Promptly Return Unused Committed Memory from G1</li>
</ul>
<h2> Java 11(GA 2018/09/25)</h2>
<ul>
<li>181: Nest-Based Access Control</li>
<li>309: Dynamic Class-File Constants</li>
<li>315: Improve Aarch64 Intrinsics</li>
<li>318: Epsilon: A No-Op Garbage Collector</li>
<li><a href="java11/jep320-remove-JavaEE-CORBA">320: Remove the Java EE and CORBA Modules</a></li>
<li>321: HTTP Client (Standard)</li>
<li>323: Local-Variable Syntax for Lambda Parameters</li>
<li>324: Key Agreement with Curve25519 and Curve448</li>
<li>327: Unicode 10</li>
<li>328: Flight Recorder</li>
<li>329: ChaCha20 and Poly1305 Cryptographic Algorithms</li>
<li>330: Launch Single-File Source-Code Programs</li>
<li>331: Low-Overhead Heap Profiling</li>
<li>332: Transport Layer Security (TLS) 1.3</li>
<li>333: ZGC: A Scalable Low-Latency Garbage Collector(Experimental)</li>
<li>335: Deprecate the Nashorn JavaScript Engine</li>
<li>336: Deprecate the Pack200 Tools and API</li>
</ul>
<h2> Java 10(GA 2018/03/20)</h2>
<ul>
<li><a href="java10/jep286-local-variable-type-inference">286: Local-Variable Type Inference</a></li>
<li>296: Consolidate the JDK Forest into a Single Repository</li>
<li>304: Garbage-Collector Interface</li>
<li>307: Parallel Full GC for G1</li>
<li>310: Application Class-Data Sharing</li>
<li>312: Thread-Local Handshakes</li>
<li>313: Remove the Native-Header Generation Tool (javah)</li>
<li>314: Additional Unicode Language-Tag Extensions</li>
<li>316: Heap Allocation on Alternative Memory Devices</li>
<li>317: Experimental Java-Based JIT Compiler</li>
<li>319: Root Certificates</li>
<li>322: Time-Based Release Versioning</li>
</ul>
<h2> Java 9(GA 2017/09/21)</h2>
<ul>
<li>102: Process API Updates</li>
<li>110: HTTP 2 Client</li>
<li>143: Improve Contended Locking</li>
<li>158: Unified JVM Logging</li>
<li>165: Compiler Control</li>
<li>193: Variable Handles</li>
<li>197: Segmented Code Cache</li>
<li>199: Smart Java Compilation, Phase Two</li>
<li>200: The Modular JDK</li>
<li>201: Modular Source Code</li>
<li>211: Elide Deprecation Warnings on Import Statements</li>
<li>212: Resolve Lint and Doclint Warnings</li>
<li>213: Milling Project Coin</li>
<li>214: Remove GC Combinations Deprecated in JDK 8</li>
<li>215: Tiered Attribution for javac</li>
<li>216: Process Import Statements Correctly</li>
<li>217: Annotations Pipeline 2.0</li>
<li>219: Datagram Transport Layer Security (DTLS)</li>
<li>220: Modular Run-Time Images</li>
<li>221: Simplified Doclet API</li>
<li><a href="java9/jep222-jshell">222: jshell: The Java Shell (Read-Eval-Print Loop)</a></li>
<li>223: New Version-String Scheme</li>
<li>224: HTML5 Javadoc</li>
<li>225: Javadoc Search</li>
<li>226: UTF-8 Property Files</li>
<li>227: Unicode 7.0</li>
<li>228: Add More Diagnostic Commands</li>
<li>229: Create PKCS12 Keystores by Default</li>
<li>231: Remove Launch-Time JRE Version Selection</li>
<li>232: Improve Secure Application Performance</li>
<li>233: Generate Run-Time Compiler Tests Automatically</li>
<li>235: Test Class-File Attributes Generated by javac</li>
<li>236: Parser API for Nashorn</li>
<li>237: Linux/AArch64 Port</li>
<li>238: Multi-Release JAR Files</li>
<li>240: Remove the JVM TI hprof Agent</li>
<li>241: Remove the jhat Tool</li>
<li>243: Java-Level JVM Compiler Interface</li>
<li>244: TLS Application-Layer Protocol Negotiation Extension</li>
<li>245: Validate JVM Command-Line Flag Arguments</li>
<li>246: Leverage CPU Instructions for GHASH and RSA</li>
<li>247: Compile for Older Platform Versions</li>
<li>248: Make G1 the Default Garbage Collector</li>
<li>249: OCSP Stapling for TLS</li>
<li>250: Store Interned Strings in CDS Archives</li>
<li>251: Multi-Resolution Images</li>
<li>252: Use CLDR Locale Data by Default</li>
<li>253: Prepare JavaFX UI Controls &amp; CSS APIs for Modularization</li>
<li>254: Compact Strings</li>
<li>255: Merge Selected Xerces 2.11.0 Updates into JAXP</li>
<li>256: BeanInfo Annotations</li>
<li>257: Update JavaFX/Media to Newer Version of GStreamer</li>
<li>258: HarfBuzz Font-Layout Engine</li>
<li>259: Stack-Walking API</li>
<li>260: Encapsulate Most Internal APIs</li>
<li>261: Module System</li>
<li>262: TIFF Image I/O</li>
<li>263: HiDPI Graphics on Windows and Linux</li>
<li>264: Platform Logging API and Service</li>
<li>265: Marlin Graphics Renderer</li>
<li>266: More Concurrency Updates</li>
<li>267: Unicode 8.0</li>
<li>268: XML Catalogs</li>
<li><a href="Java9/jep269-convenience-factory-methods-for-collections">269: Convenience Factory Methods for Collections</a></li>
<li>270: Reserved Stack Areas for Critical Sections</li>
<li>271: Unified GC Logging</li>
<li>272: Platform-Specific Desktop Features</li>
<li>273: DRBG-Based SecureRandom Implementations</li>
<li>274: Enhanced Method Handles</li>
<li>275: Modular Java Application Packaging</li>
<li>276: Dynamic Linking of Language-Defined Object Models</li>
<li>277: Enhanced Deprecation</li>
<li>278: Additional Tests for Humongous Objects in G1</li>
<li>279: Improve Test-Failure Troubleshooting</li>
<li>280: Indify String Concatenation</li>
<li>281: HotSpot C++ Unit-Test Framework</li>
<li>282: jlink: The Java Linker</li>
<li>283: Enable GTK 3 on Linux</li>
<li>284: New HotSpot Build System</li>
<li>285: Spin-Wait Hints</li>
<li>287: SHA-3 Hash Algorithms</li>
<li>288: Disable SHA-1 Certificates</li>
<li>289: Deprecate the Applet API</li>
<li>290: Filter Incoming Serialization Data</li>
<li>291: Deprecate the Concurrent Mark Sweep (CMS) Garbage Collector</li>
<li>292: Implement Selected ECMAScript 6 Features in Nashorn</li>
<li>294: Linux/s390x Port</li>
<li>295: Ahead-of-Time Compilation</li>
<li>297: Unified arm32/arm64 Port</li>
<li>298: Remove Demos and Samples</li>
<li>299: Reorganize Documentation</li>
</ul>
<h2> Java 8(GA 2014/03/18)</h2>
]]></content:encoded>
    </item>
    <item>
      <title>Java 9 新特性：交互式编程环境JShell</title>
      <link>https://www.geekyspace.cn/java-features/Java9/jep222-jshell.html</link>
      <guid>https://www.geekyspace.cn/java-features/Java9/jep222-jshell.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 9 新特性：交互式编程环境JShell</source>
      <description>Java 9 新特性：交互式编程环境JShell JShell 是 Java 9 引入的一个交互式编程环境，它是 Java 编程语言的 REPL（Read-Eval-Print Loop）实现。 REPL 是一种编程环境，允许用户输入表达式并立即看到结果，而无需事先编写和编译完整的程序。 JShell 的目标是提供一个轻量级、灵活且易于使用的工具，使得 Java 开发者能够更直观地编写和测试代码。 JShell快速入门 启动JShell 打开终端，然后执行命令：jshell，执行效果如下：</description>
      <category>Java</category>
      <pubDate>Thu, 21 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java 9 新特性：交互式编程环境JShell</h1>
<p>JShell 是 Java 9 引入的一个交互式编程环境，它是 Java 编程语言的 REPL（Read-Eval-Print Loop）实现。
REPL 是一种编程环境，允许用户输入表达式并立即看到结果，而无需事先编写和编译完整的程序。
JShell 的目标是提供一个轻量级、灵活且易于使用的工具，使得 Java 开发者能够更直观地编写和测试代码。</p>
<h2> JShell快速入门</h2>
<h3> 启动JShell</h3>
<p>打开终端，然后执行命令：<code>jshell</code>，执行效果如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 帮助介绍 /help intro</h3>
<p>执行 <code>/help intro</code> 命令以获取有关 JShell 工具的简要介绍，<strong>intro</strong> 是主题，提供了关于 jshell 工具的核心概念和使用方法的信息。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 定义变量、方法、类</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 执行表达式、调用方法</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 查看定义的变量：/vars</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 查看定义的方法：/methods</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 查看定义的类：/types</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 列出输入源条目：/list</h2>
<p>执行后，可以看到之前在<code>jshell</code>中输入的内容清单：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 编辑源条目：/edit</h2>
<p>上面通过<code>/list</code>列出了输入的条目信息，下面试试通过<code>/edit</code>编辑下，比如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这将打开编辑器，修改先前定义的 <code>square</code> 方法。</p>
<p>修改完成后，点击 <strong>accept</strong> 即可</p>
<h2> 删除源条目：/drop</h2>
<p>使用 <code>/drop</code> 命令可以删除之前输入的源代码块。可以通过指定<strong>名称</strong>或 <strong>ID</strong> 删除特定的源代码块。例如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这将删除之前定义的 <code>Message</code> 类。</p>
<h2> 保存文件：/save</h2>
<p>通过 <code>/save</code> 命令，您可以将 JShell 中的源代码保存到文件中，以便将其保留或与他人共享。例如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这将把当前所有的源代码保存到一个名为 <code>myCode.java</code> 的文件中。</p>
<h2> 打开文件：/open</h2>
<p>使用 <code>/open</code> 命令可以将文件的内容导入到 JShell 中，以便重新使用或修改。例如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这将导入之前保存的 <code>myCode.java</code> 文件中的源代码。</p>
<h2> 重置jshell：/reset</h2>
<p>使用 <code>/reset</code> 命令可以清空 JShell 的状态，包括所有定义的变量、方法和类。例如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这将重置 JShell 并清除所有之前定义的内容。</p>
<h2> 查看引入的包：/imports</h2>
<p>使用 <code>/imports</code> 命令可以查看当前已经导入的包。这对于确保您在 JShell 中能够访问所需的类和方法非常有用。例如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这表明已经导入了 <code>java.util</code> 包。</p>
<h2> 退出jshell：/exit</h2>
<p>使用 <code>/exit</code> 命令可以退出 JShell。如果需要，在命令后可以添加一个整数表达式片段作为退出代码。例如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这将以退出代码 0 退出 JShell。</p>
<h2> 查看命令：/help</h2>
<p>最后，使用 <code>/help</code> 命令可以随时查看 JShell 的帮助信息，了解各种命令和主题的使用方法。例如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这将显示 JShell 的主要帮助信息。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 9 新特性：不可变集合的快捷创建方法</title>
      <link>https://www.geekyspace.cn/java-features/Java9/jep269-convenience-factory-methods-for-collections.html</link>
      <guid>https://www.geekyspace.cn/java-features/Java9/jep269-convenience-factory-methods-for-collections.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">Java 9 新特性：不可变集合的快捷创建方法</source>
      <description>Java 9 新特性：不可变集合的快捷创建方法 Java 9引入了一项令人期待的新特性，即“Convenience Factory Methods for Collections”（集合的便利工厂方法），旨在使不可变集合的创建更加简单和便捷。 在此之前，我们通常使用构造方法来初始化集合，而Java 9为我们提供了一些全新的静态工厂方法，使得创建不可变集合的过程更为优雅。 Java 9的集合创建方式 Java 9引入了一些便利的工厂方法，使得创建和初始化集合对象变得更加简洁和方便。 这些改进包括List.of()、Set.of()和Map.of()等方法，用于创建不可变的集合对象。</description>
      <category>Java</category>
      <pubDate>Fri, 22 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java 9 新特性：不可变集合的快捷创建方法</h1>
<p>Java 9引入了一项令人期待的新特性，即“Convenience Factory Methods for Collections”（集合的便利工厂方法），旨在使不可变集合的创建更加简单和便捷。
在此之前，我们通常使用构造方法来初始化集合，而Java 9为我们提供了一些全新的静态工厂方法，使得创建不可变集合的过程更为优雅。</p>
<h2> Java 9的集合创建方式</h2>
<p>Java 9引入了一些便利的工厂方法，使得创建和初始化集合对象变得更加简洁和方便。
这些改进包括List.of()、Set.of()和Map.of()等方法，用于创建不可变的集合对象。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样一行代码就完成了整个集合的创建和初始化过程，使得代码更加简洁、清晰，并且具有更高的可读性。</p>
<h2> Java 8的集合创建方式</h2>
<p>Java 8引入了Lambda表达式和流式操作，这使得集合的初始化过程变得更加流畅和具有函数式编程的特性。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然相较于传统方式，Java 8的写法更为紧凑，但仍显得略显繁琐。</p>
<h2> 传统的集合创建方式</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方式繁琐且不够直观，给代码的可读性和编写效率带来了一定的挑战。</p>
<h2> List.of() vs. Arrays.asList()</h2>
<ul>
<li>
<p><strong>可变性：</strong><code>List.of</code> 创建的是不可变集合，<code>Arrays.asList</code> 是可变集合</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>null元素：</strong><code>List.of</code> 不允许包含 null 元素，<code>Arrays.asList</code> 允许包含 null 元素，但不推荐</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p><strong>底层数据结构：</strong><code>List.of </code>使用不可变数据结构，<code>Arrays.asList</code>底层使用数组，对列表修改将反映在原始数组上</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>个人简介</title>
      <link>https://www.geekyspace.cn/intro.html</link>
      <guid>https://www.geekyspace.cn/intro.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">个人简介</source>
      <description>个人简介</description>
      <category>程序人生</category>
      <pubDate>Mon, 14 Dec 1998 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 个人简介</h1>
<p>我是一名会敲代码的程序员，对技术有着强烈的热爱，喜欢专研，分享，捣鼓各种有趣的新玩意。</p>
<p>自认为自己并不是一个聪明的人，也不会有好运会落在我身上；</p>
<p>做事情只做有把握的事情，前提就是要有把握，为之努力，不达目的不罢休。</p>
<p>人特别轴，较真！</p>
<p>我的标语：<mark><strong>当坚持成为一种热爱，极致成为一种精神，那么成功就是一种必然。</strong></mark></p>
]]></content:encoded>
      <enclosure url="https://www.geekyspace.cn/assets/images/cover3.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>幻灯片页</title>
      <link>https://www.geekyspace.cn/slides.html</link>
      <guid>https://www.geekyspace.cn/slides.html</guid>
      <source url="https://www.geekyspace.cn/rss.xml">幻灯片页</source>
      <description>@slidestart 幻灯片演示 一个简单的幻灯片演示与各种小贴士。 作者 Mr.Hope. 请滚动鼠标滚轮进入下一页 标注幻灯片</description>
      <pubDate>Mon, 11 Dec 2023 17:02:31 GMT</pubDate>
      <content:encoded><![CDATA[<!-- markdownlint-disable MD024 MD051 -->
<p>@slidestart</p>
<!-- .slide: data-transition="slide" -->
<h2> 幻灯片演示</h2>
<!-- .element: class="r-fit-text" -->
<p>一个简单的幻灯片演示与各种小贴士。</p>
<!-- .element: class="r-fit-text" -->
<blockquote>
<p>作者 Mr.Hope. 请滚动鼠标滚轮进入下一页</p>
</blockquote>
<hr>
<h2> 标注幻灯片</h2>
<!-- .element: class="r-fit-text" -->
<p><a href="#/1/1">👇</a></p>
<p>--</p>
<h2> 标注幻灯片</h2>
<!-- .element: class="r-fit-text" -->
<p>使用 <code>---</code> 标注水平幻灯片</p>
<!-- .element: class="fragment fade-in" -->
<p>在水平幻灯片中使用 <code>--</code> 分割垂直幻灯片</p>
<!-- .element: class="fragment fade-in" -->
<p>使用 <code>&lt;!-- .slide: ... --&gt;</code> 在幻灯片上添加属性</p>
<!-- .element: class="fragment fade-in" -->
<p>使用 <code>&lt;!-- .element: ... --&gt;</code> 在前一个 HTML 元素上添加属性</p>
<!-- .element: class="fragment fade-in" -->
<hr>
<!-- .slide: data-transition="slide" data-auto-animate -->
<h2> Markdown</h2>
<!-- .element: class="r-fit-text" -->
<p>你可以在幻灯片中使用 Markdown 语法的各种标记.</p>
<!-- .element: class="r-fit-text" -->
<p>--</p>
<!-- .slide: data-auto-animate -->
<h2> Markdown</h2>
<p>你可以在幻灯片中使用 Markdown 语法的各种标记.</p>
<h3> 这是一个 H3</h3>
<p>标题默认会自动转换为大写。</p>
<p>这是一个有着 <strong>粗体</strong>, <em>斜体</em>, <s>删除线</s> 文字并包含 <a href="https://mister-hope.com" target="_blank" rel="noopener noreferrer">一个链接</a> 的段落，并且它会自动换行。所以你无需担心它的长度。</p>
<p>--</p>
<!-- .slide: data-auto-animate -->
<h2> Markdown</h2>
<p>你可以在幻灯片中使用 Markdown 语法的各种标记.</p>
<p>列表默认为 <code>inline-block</code></p>
<ul>
<li>项目</li>
<li>项目</li>
<li>项目</li>
</ul>
<ol>
<li>项目 1</li>
<li>项目 2</li>
<li>项目 3</li>
</ol>
<p>--</p>
<!-- .slide: data-auto-animate -->
<h2> Markdown</h2>
<p>你可以在幻灯片中使用 Markdown 语法的各种标记.</p>
<p>在你启用 <code>highlight</code> 插件后，代码块会自动高亮。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>--</p>
<!-- .slide: data-auto-animate -->
<h2> Markdown</h2>
<p>你可以在幻灯片中使用 Markdown 语法的各种标记.</p>
<p>在你启用 <code>math</code> 插件后，你也可以使用 TEX 格式使用数学公式。</p>
<p>$$
J(\theta_0,\theta_1) = \sum_{i=0}
$$</p>
<p>--</p>
<!-- .slide: data-auto-animate -->
<h2> Markdown</h2>
<p>你可以在幻灯片中使用 Markdown 语法的各种标记.</p>
<p>⚠<strong>请注意</strong>: 表格和分割线，以及所有不在 Markdown 标准语法中的内容均不受支持。</p>
<hr>
<!-- .slide: data-transition="slide" data-auto-animate -->
<h2> 布局</h2>
<!-- .element: class="r-fit-text" -->
<p>--</p>
<!-- .slide: data-auto-animate  -->
<h2> 布局</h2>
<!-- .element: class="r-fit-text" -->
<p>👆 <code>r-fit-text</code> class 会让文字在不超出幻灯片范围的情况下尽可能大。</p>
<p>--</p>
<!-- .slide: data-auto-animate  -->
<h2> 布局</h2>
<figure><img src="/logo.svg" alt="Logo" tabindex="0" loading="lazy"><figcaption>Logo</figcaption></figure>
<!-- .element: class="r-stretch" -->
<p>👆 <code>r-stretch</code> class 帮助你控制注入图片或视频的大小，使它们填充满幻灯片垂直方向上的剩余空间。</p>
<p>--</p>
<!-- .slide: data-auto-animate data-background-color="rgb(70, 70, 255)" -->
<h2> 布局</h2>
<h3> 背景</h3>
<p>你可以通过向特定幻灯片添加 <code>data-background</code> 属性自定义幻灯片背景.</p>
<hr>
<!-- .slide: data-auto-animate -->
<h2> 动画片段</h2>
<!-- .element: class="r-fit-text" -->
<p>--</p>
<!-- .slide: data-auto-animate -->
<h2> 动画片段</h2>
<!-- .element: class="r-fit-text" -->
<p>动画片段用于高亮或显隐幻灯片中的元素。</p>
<p>你需要在元素上添加 <code>fragment</code> 和动画 class。</p>
<p>--</p>
<!-- .slide: data-auto-animate -->
<h2> 动画片段</h2>
<h3> 动画 class</h3>
<ul>
<li><code>fade-in</code></li>
</ul>
<!-- .element: class="fragment fade-in" -->
<ul>
<li><code>fade-out</code></li>
</ul>
<!-- .element: class="fragment fade-out" -->
<ul>
<li><code>fade-up</code></li>
</ul>
<!-- .element: class="fragment fade-up" -->
<!-- list break -->
<ul>
<li><code>fade-down</code></li>
</ul>
<!-- .element: class="fragment fade-down" -->
<ul>
<li><code>fade-left</code></li>
</ul>
<!-- .element: class="fragment fade-left" -->
<ul>
<li><code>fade-right</code></li>
</ul>
<!-- .element: class="fragment fade-right" -->
<!-- list break -->
<ul>
<li><code>fade-in-then-out</code></li>
</ul>
<!-- .element: class="fragment fade-in-then-out" -->
<ul>
<li><code>fade-in-then-semi-out</code></li>
</ul>
<!-- .element: class="fragment fade-in-then-semi-out" -->
<p>--</p>
<!-- .slide: data-auto-animate -->
<h2> 动画片段</h2>
<h3> 动画 class</h3>
<ul>
<li><code>grow</code></li>
</ul>
<!-- .element: class="fragment grow" -->
<ul>
<li><code>shrink</code></li>
</ul>
<!-- .element: class="fragment shrink" -->
<ul>
<li><code>strike</code></li>
</ul>
<!-- .element: class="fragment strike" -->
<!-- list break -->
<ul>
<li><code>highlight-red</code></li>
</ul>
<!-- .element: class="fragment highlight-red" -->
<ul>
<li><code>highlight-green</code></li>
</ul>
<!-- .element: class="fragment highlight-green" -->
<ul>
<li><code>highlight-blue</code></li>
</ul>
<!-- .element: class="fragment highlight-blue" -->
<!-- list break -->
<ul>
<li><code>highlight-current-red</code></li>
</ul>
<!-- .element: class="fragment highlight-current-red" -->
<ul>
<li><code>highlight-current-green</code></li>
</ul>
<!-- .element: class="fragment highlight-current-green" -->
<ul>
<li><code>highlight-current-blue</code></li>
</ul>
<!-- .element: class="fragment highlight-current-blue" -->
<p>--</p>
<!-- .slide: data-auto-animate -->
<h2> 动画片段</h2>
<h3> 多个动画片段</h3>
<p>你可以按照顺序包裹一个 HTML 元素使其拥有多个动画片段</p>
<span class="fragment fade-in">
  <span class="fragment highlight-red">
    <span class="fragment fade-out">
      渐入 &gt; 变红 &gt; 渐出
    </span>
  </span>
</span>
<p>--</p>
<!-- .slide: data-auto-animate -->
<h2> 动画片段</h2>
<h3> 顺序</h3>
<p>你可以使用 <code>data-fragment-index</code> 属性改变元素的动画顺序。</p>
<p>不同元素可以有相同的动画顺序。</p>
<ul>
<li>最后显示</li>
</ul>
<!-- .element: class="fragment" data-fragment-index="3"-->
<ul>
<li>第二个显示</li>
</ul>
<!-- .element: class="fragment" data-fragment-index="2"-->
<!-- list break -->
<ul>
<li>第一个显示</li>
</ul>
<!-- .element: class="fragment" data-fragment-index="1"-->
<ul>
<li>第二个显示</li>
</ul>
<!-- .element: class="fragment" data-fragment-index="2"-->
<hr>
<!-- .slide: data-transition="slide" data-auto-animate -->
<h2> 渐变</h2>
<!-- .element: class="r-fit-text" -->
<p>--</p>
<!-- .slide: data-transition="slide" data-auto-animate -->
<h2> 渐变</h2>
<!-- .element: class="r-fit-text" -->
<p>Transition 可以通过配置中的 <code>transition</code> 选项全局设置，也可以通过在特定幻灯片添加 <code>data-transition</code> 属性局部设置.</p>
<p>可能的值:</p>
<ul>
<li>none</li>
<li>fade</li>
<li>slide</li>
</ul>
<!-- list break -->
<ul>
<li>convex</li>
<li>concave</li>
<li>zoom</li>
</ul>
<p>--</p>
<!-- .slide: data-auto-animate -->
<h2> 渐变</h2>
<!-- .element: class="r-fit-text" -->
<h3> 过渡动画</h3>
<p>你可以在相邻的幻灯片上添加 <code>data-auto-animate</code> 使相同的 HTML 元素产生过渡动画效果。</p>
<hr>
<!-- .slide: data-transition="slide" data-auto-animate -->
<h2> 功能</h2>
<!-- .element: class="r-fit-text" -->
<p>--</p>
<!-- .slide: data-transition="slide" data-auto-animate -->
<h2> 功能</h2>
<!-- .element: class="r-fit-text" -->
<h3> 代码</h3>
<p>通过启用 <code>highlight</code> 插件，你可以对代码块进行高亮。</p>
<p>你可以使用 <code>[a-b|c-d]</code> 语法来分布高亮特定行。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>--</p>
<!-- .slide: data-transition="slide" data-auto-animate -->
<h2> 功能</h2>
<!-- .element: class="r-fit-text" -->
<h3> 预览模式</h3>
<p>按下 <code>Esc</code> 或 <code>O</code> 即可在幻灯片获得焦点时进入预览模式。</p>
<p>--</p>
<!-- .slide: data-transition="slide" data-auto-animate -->
<h2> 功能</h2>
<!-- .element: class="r-fit-text" -->
<h3> 全屏模式</h3>
<p>按下 <code>F</code> 或 <code>F11</code> 即可在幻灯片获得焦点时进入全屏模式。</p>
<p>--</p>
<!-- .slide: data-transition="slide" data-auto-animate -->
<h2> 功能</h2>
<!-- .element: class="r-fit-text" -->
<h3> 缩放</h3>
<p>按下 <code>alt</code> (Linux 上使用 <code>ctrl</code>) 的同时点击幻灯片的任何元素，即可以向此元素进行放大。</p>
<p>再次点击即可缩小。</p>
<hr>
<!-- .element: class="r-fit-text" -->
<h2> 结束</h2>
<p>@slideend</p>
]]></content:encoded>
      <enclosure url="https://www.geekyspace.cn/logo.svg" type="image/svg+xml"/>
    </item>
  </channel>
</rss>