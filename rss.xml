<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://joeljhou/joeljhou/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://joeljhou/joeljhou/rss.xml" rel="self" type="application/rss+xml"/>
    <title>会敲代码的程序猿</title>
    <link>https://joeljhou/joeljhou/</link>
    <description>vuepress-theme-hope 的博客搭建</description>
    <language>zh-CN</language>
    <pubDate>Thu, 04 Jan 2024 02:34:24 GMT</pubDate>
    <lastBuildDate>Thu, 04 Jan 2024 02:34:24 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>Java</category>
    <item>
      <title>Java 17 新特性：switch的模式匹配（Preview）</title>
      <link>https://joeljhou/joeljhou/java-features/Java17/jep406-pattern-matching-for-switch-preview.html</link>
      <guid>https://joeljhou/joeljhou/java-features/Java17/jep406-pattern-matching-for-switch-preview.html</guid>
      <source url="https://joeljhou/joeljhou/rss.xml">Java 17 新特性：switch的模式匹配（Preview）</source>
      <description>Java 17 新特性：switch的模式匹配（Preview）</description>
      <category>Java</category>
      <pubDate>Sat, 30 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java 17 新特性：switch的模式匹配（Preview）</h1>
]]></content:encoded>
    </item>
    <item>
      <title>Java 17 新特性：密封类</title>
      <link>https://joeljhou/joeljhou/java-features/Java17/jep409-sealed-classes.html</link>
      <guid>https://joeljhou/joeljhou/java-features/Java17/jep409-sealed-classes.html</guid>
      <source url="https://joeljhou/joeljhou/rss.xml">Java 17 新特性：密封类</source>
      <description>Java 17 新特性：密封类</description>
      <category>Java</category>
      <pubDate>Sun, 31 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java 17 新特性：密封类</h1>
]]></content:encoded>
    </item>
    <item>
      <title>Java 16 新特性：instanceof增强</title>
      <link>https://joeljhou/joeljhou/java-features/Java16/jep394-pattern-matching-for-instanceof.html</link>
      <guid>https://joeljhou/joeljhou/java-features/Java16/jep394-pattern-matching-for-instanceof.html</guid>
      <source url="https://joeljhou/joeljhou/rss.xml">Java 16 新特性：instanceof增强</source>
      <description>Java 16 新特性：instanceof增强 Java 16 引入了 instanceof 的增强语法，用于更简便地判断对象是否是某个类的实例并进行相应的局部类型转换。 instanceof 基础用法 if (obj instanceof String) { String someString = (String) obj; // 强制类型转换 // ... }</description>
      <category>Java</category>
      <pubDate>Thu, 28 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java 16 新特性：instanceof增强</h1>
<p>Java 16 引入了 <code>instanceof</code> 的增强语法，用于更简便地判断对象是否是某个类的实例并进行相应的<strong>局部类型转换</strong>。</p>
<h2> instanceof 基础用法</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个<strong>强制转换</strong>通常是在 <code>instanceof</code> 检查之后 的第一件事，所以为什么不围绕它优化一下语法呢？</p>
<h2> instanceof 增强用法</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol>
<li>若 <code>instanceof</code> 检查成功，将自动将变量转换为指定类型</li>
<li>定义的变量实质上是一个<strong>局部变量</strong>，只在if语句的范围内可见</li>
</ol>
<h2> 常见用法建议</h2>
<p>不仅如此！使用模式匹配，我们可以更灵活地应用条件测试。</p>
<ul>
<li>
<p>利用已定义的 obj，在不需要额外嵌套的情况下判断字符串是否以“Awesome”开头</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>甚至在 equals 方法中，代码会更加简洁</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<p>多么不同！现在代码简洁而直观。</p>
<h2> 发展脉络</h2>
<p>该功能经历了2个预览版本（JDK 14中的JEP 305、JDK 15中的JEP 375），最终定稿于JDK 16中的JEP 394。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 16 新特性：record类</title>
      <link>https://joeljhou/joeljhou/java-features/Java16/jep395-records.html</link>
      <guid>https://joeljhou/joeljhou/java-features/Java16/jep395-records.html</guid>
      <source url="https://joeljhou/joeljhou/rss.xml">Java 16 新特性：record类</source>
      <description>Java 16 新特性：record类 Java 16引入的record类是一种用于简化不可变数据管理的特殊类。 它通过紧凑的语法提供了对不可变数据的支持，并自动生成常见的方法， 如equals()、hashCode()和toString()等，从而减少了开发者的样板代码。 传统Java Bean问题 在处理不可变数据时，传统的Java Bean存在“繁琐”和“冗长”的问题。 为了管理少量值的不可变数据，开发者需要编写大量低价值、重复且容易出错的代码， 包括构造函数、访问器(getter/setter)、equals、hashCode、toString等。</description>
      <category>Java</category>
      <pubDate>Fri, 29 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java 16 新特性：record类</h1>
<p>Java 16引入的<code>record</code>类是一种用于简化不可变数据管理的特殊类。
它通过紧凑的语法提供了对不可变数据的支持，并自动生成常见的方法，
如<code>equals()</code>、<code>hashCode()</code>和<code>toString()</code>等，从而减少了开发者的样板代码。</p>
<h2> 传统Java Bean问题</h2>
<p>在处理不可变数据时，传统的Java Bean存在“<mark>繁琐</mark>”和“<mark>冗长</mark>”的问题。
为了管理少量值的不可变数据，开发者需要编写大量低价值、重复且容易出错的代码，
包括<code>构造函数</code>、<code>访问器(getter/setter)</code>、<code>equals</code>、<code>hashCode</code>、<code>toString</code>等。</p>
<p>例如，用于携带x和y坐标的类通常会演变成以下繁琐形式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 引入record类</h2>
<p><strong>语法如下</strong>：使用 <code>record</code><mark>关键字</mark>，指定<mark>类名称</mark>为 Point，定义<mark>参数列表</mark> x 和 y 作为组件</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>record申明的类，具备这些特点：</p>
<ol>
<li>它是一个<code>final</code>类</li>
<li>自动实现<code>equals</code>、<code>hashCode</code>、<code>toString</code>函数</li>
<li>成员变量均为<code>public</code>属性</li>
</ol>
<p>所以，对于之前写的Point类，它等价于一个这样的类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过使用record类，你可以更专注于业务逻辑而不是样板代码，提高了代码的可读性和可维护性。</p>
<h2> 显示声明紧凑构造函数</h2>
<p>未显式声明构造函数时，系统会自动生成包含所有成员变量的隐式构造函数。
当显式声明紧凑构造函数可以<mark>省略形式参数列表</mark>、编译后在构造函数的末尾<mark>自动分配</mark>给相应的形式参数（this.x = x;）。</p>
<ul>
<li>
<p><strong>验证参数</strong>的紧凑构造函数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>规范</strong>的紧凑构造函数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个声明等同于传统的构造函数形式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>记录类<strong>语义一致性</strong></p>
<p>例如，考虑以下方式声明的记录类R：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果通过以下方式复制R的实例r1：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>则假设 r1 不是空引用，表达式 r1.equals(r2) 总是为 true。
这是因为记录类的隐式声明的 equals 方法保证了相同字段值的两个记录实例相等。</p>
<blockquote>
<p>Tips: 程序员需要谨慎确保显式声明的方法维持语义一致性</p>
</blockquote>
</li>
<li>
<p>避免不良风格的代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是一个不良风格的代码，违反了语义一致性的原则，访问器<code>x()</code>,<code>y()</code>方法调整类实例的状态；
<strong>改进建议</strong>， 如果需要限制坐标值的范围，应该在构造函数或其他明确的位置处理。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h2> 发展脉络</h2>
<p><code>record</code> 类最初在JDK 14预览版(JEP 359)提出，随后在JDK 15预览版(JEP 384)再次推出。
最终，它在JDK 16中(JEP 395)正式发布，成为Java语言的一项重要特性。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 15 新特性：隐藏类</title>
      <link>https://joeljhou/joeljhou/java-features/Java15/jep371-hidden-classes.html</link>
      <guid>https://joeljhou/joeljhou/java-features/Java15/jep371-hidden-classes.html</guid>
      <source url="https://joeljhou/joeljhou/rss.xml">Java 15 新特性：隐藏类</source>
      <description>Java 15 新特性：隐藏类 Hidden Classes 提供了一种在运行时生成类的机制，在编译时未知，并且不能直接在源代码中引用， 需要通过反射间接使用它们，隐藏类是为框架设计的，具有以下特性： 动态生成内部类：隐藏类天生为框架设计，在运行时生成内部类 反射访问限制：隐藏类只能通过反射访问，不能直接被其他类的字节码访问 独立加载和卸载：隐藏类可以独立于其他类加载和卸载 框架扩展性：适用于需要在运行时生成类的框架，提高语言的灵活性和效率</description>
      <category>Java</category>
      <pubDate>Tue, 26 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java 15 新特性：隐藏类</h1>
<p>Hidden Classes 提供了一种在运行时生成类的机制，在编译时未知，并且不能直接在源代码中引用，
需要通过反射间接使用它们，隐藏类是为框架设计的，具有以下特性：</p>
<ul>
<li><strong>动态生成内部类</strong>：隐藏类天生为框架设计，在运行时生成内部类</li>
<li><strong>反射访问限制</strong>：隐藏类只能通过反射访问，不能直接被其他类的字节码访问</li>
<li><strong>独立加载和卸载</strong>：隐藏类可以独立于其他类加载和卸载</li>
<li><strong>框架扩展性</strong>：适用于需要在运行时生成类的框架，提高语言的灵活性和效率</li>
</ul>
<h2> 原理</h2>
<h2> 框架中应用</h2>
<p><a href="https://bugs.openjdk.org/browse/JDK-8220607" target="_blank" rel="noopener noreferrer">https://bugs.openjdk.org/browse/JDK-8220607</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 15 新特性：文本块</title>
      <link>https://joeljhou/joeljhou/java-features/Java15/jep378-text-blocks.html</link>
      <guid>https://joeljhou/joeljhou/java-features/Java15/jep378-text-blocks.html</guid>
      <source url="https://joeljhou/joeljhou/rss.xml">Java 15 新特性：文本块</source>
      <description>Java 15 新特性：文本块 Java 15（JEP 378）引入了文本块（Text Blocks）这一新特性，旨在简化多行字符串的表示，提高代码可读性，并减少在字符串中使用转义符的需求。 文本块通过引入三个双引号的胖分隔符（&amp;quot;&amp;quot;&amp;quot;）来实现，同时支持转义序列，为开发人员提供更直观、易读的字符串处理方式。 快速上手 HTML示例 // 使用“一维”字符串文字 String html = &amp;quot;&amp;lt;html&amp;gt;\n&amp;quot; + &amp;quot; &amp;lt;body&amp;gt;\n&amp;quot; + &amp;quot; &amp;lt;p&amp;gt;Hello, world&amp;lt;/p&amp;gt;\n&amp;quot; + &amp;quot; &amp;lt;/body&amp;gt;\n&amp;quot; + &amp;quot;&amp;lt;/html&amp;gt;\n&amp;quot;; // 使用“二维”文本块 String html = &amp;quot;&amp;quot;&amp;quot; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;p&amp;gt;Hello, world&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; &amp;quot;&amp;quot;&amp;quot;;</description>
      <category>Java</category>
      <pubDate>Wed, 27 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java 15 新特性：文本块</h1>
<p>Java 15（JEP 378）引入了文本块（Text Blocks）这一新特性，旨在简化多行字符串的表示，提高代码可读性，并减少在字符串中使用转义符的需求。
文本块通过引入三个双引号的<strong>胖分隔符</strong>（<code>"""</code>）来实现，同时支持转义序列，为开发人员提供更直观、易读的字符串处理方式。</p>
<h2> 快速上手</h2>
<p><strong>HTML示例</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>SQL示例</strong></p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Polyglot语言示例</strong></p>
<div class="language-polyglot line-numbers-mode" data-ext="polyglot"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 编译时处理</h2>
<p>文本块是String类型的常量表达式，类似于字符串字面量。然而，与字符串字面值不同，文本块的内容在编译时经历三个步骤的处理：<mark>行终止符的规范化</mark>、<mark>附带白色空间的移除</mark>和<mark>解释转义序列</mark>：</p>
<ol>
<li>转换内容的行终止符
<ul>
<li>行终止符从CR（\u000D）和CRLF（\u000D\u000A）规范化为<code>LF（\u000A）</code></li>
</ul>
</li>
<li>删除内容周围附带的白色空间（用于匹配Java源代码的缩进）</li>
<li>解释内容中的转义序列，执行解释作为最后一步开发人员可以编写转义序列，如\n，而不会被前面的步骤修改或删除</li>
</ol>
<p>处理后的内容以<code>CONSTANT_String_info</code>形式记录在<strong>类文件的常量池</strong>中，运行时，文本块被计算为String的实例。</p>
<h2> 新增转义序列</h2>
<p>为了更精细地控制<mark>换行符</mark>和<mark>空格</mark>的处理，引入了两个新的转义序列：\ &lt;line-terminator&gt; 和 \s。</p>
<h3> 换行符 \ &lt;line-terminator&gt;</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>Tips： 因为字符和传统字符串不允许嵌入换行符，所以\ &lt;line-terminator&gt; 转义序列只适用于文本块</p>
</blockquote>
<h3> 单个空格 \s</h3>
<p>新的 \s 转义序列简单地转换为单个空格（\u0020）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>转义序列直到去除无意义的空格后才被解释，\s 可以作为栅栏，防止尾随空格被去除。
在这个示例中，每行末尾使用 \s 可以确保每行长度恰好为六个字符。</p>
<h2> 文本块连接</h2>
<p>文本块的连接是引入的一个方便的特性，使得字符串的拼接变得更加简洁。
在连接时，相邻的文本块将自动合并，无需显式使用加号连接操作符。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，两个相邻的文本块会自动连接，形成一个整体的字符串。
这种自动连接的特性让代码更加清晰，减少了冗余的拼接操作。</p>
<h2> 文本块新方法</h2>
<p>文本块引入了一些新方法，以便更方便地处理多行字符串：</p>
<ul>
<li><code>String::stripIndent()</code>：去除多行字符串的前导空格</li>
<li><code>String::translateEscapes()</code>：转义多行字符串中的转义字符</li>
<li><code>String::formatted()</code>：在文本块中使用占位符进行值替换</li>
<li><code>String::lines()：</code>：将多行字符串拆分为行的流，方便逐行处理。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java 14 新特性：switch表达式增强</title>
      <link>https://joeljhou/joeljhou/java-features/Java14/jep361-switch-expressions.html</link>
      <guid>https://joeljhou/joeljhou/java-features/Java14/jep361-switch-expressions.html</guid>
      <source url="https://joeljhou/joeljhou/rss.xml">Java 14 新特性：switch表达式增强</source>
      <description>Java 14 新特性：switch表达式增强 Java 14（JEP 361）引入了 switch 表达式的新特性，其中包括了 &amp;quot;箭头标签（case ... -&amp;gt;）&amp;quot; 和 yield 语句的增强， 同时支持 Lambda 语法，使得代码更加灵活、简洁，并为未来的模式匹配（JEP 305）特性做好了准备。 传统的switch语句 首先，让我们回顾一下传统的switch语句，它们在处理多个条件时可能显得有些冗长：</description>
      <category>Java</category>
      <pubDate>Mon, 25 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java 14 新特性：switch表达式增强</h1>
<p>Java 14（JEP 361）引入了 switch 表达式的新特性，其中包括了 "箭头标签（<code>case ... -&gt;</code>）" 和 <code>yield</code> 语句的增强，
同时支持 <code>Lambda</code> 语法，使得代码更加灵活、简洁，并为未来的<strong>模式匹配</strong>（JEP 305）特性做好了准备。</p>
<h2> 传统的switch语句</h2>
<p>首先，让我们回顾一下传统的switch语句，它们在处理多个条件时可能显得有些冗长：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>传统的 switch 语句存在以下问题：</p>
<ol>
<li>设计受到C和C++等低级语言的影响，且默认支持fall through语义</li>
<li>过多的<code>break</code>语句使得代码显得冗长</li>
</ol>
<h2> switch表达式增强</h2>
<h3> 箭头标签（case L -&gt;）</h3>
<ol>
<li>引入了一种新的开关标签"<code>case L -&gt;</code>"，用于表示只有一个分支的情况</li>
<li>允许每种情况下有多个常量，用逗号分隔</li>
<li>标签右侧的代码仅限于表达式、块或抛出异常throw语句</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 局部变量独立作用域</h3>
<p>在 Java 14 中，允许在每个分支中声明局部变量，避免块中变量命名冲突和误用。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> switch表达式</h3>
<p>Switch 表达式被引入，允许将 <code>switch</code> 语句用作表达式，通过 <code>Lambda</code> 语法，根据输入值返回不同的结果。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Switch表达式的常见形式如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>Switch表达式是多态表达式（poly expression）。</p>
<p>多态性是指在编译时不确定具体类型，而在运行时确定类型的特性。</p>
</blockquote>
<h3> yield语句返回值</h3>
<p>允许在switch表达式中使用<code>yield</code>语句，而不是使用<code>break</code>语句，用于返回一个值，结束switch表达式的执行。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 发展脉络</h2>
<p>追溯JEP 361的发展历程：从JDK 12预览版(JEP 325)到JDK 13预览版(JEP 354)，
虽然部分功能在早期版本中已经出现，但建议在 JDK 14 及以后的版本中使用，以获得更好的稳定性和支持。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 11 新特性 ：移除JavaEE和CORBA模块以及JavaFX</title>
      <link>https://joeljhou/joeljhou/java-features/Java11/jep320-remove-JavaEE-CORBA.html</link>
      <guid>https://joeljhou/joeljhou/java-features/Java11/jep320-remove-JavaEE-CORBA.html</guid>
      <source url="https://joeljhou/joeljhou/rss.xml">Java 11 新特性 ：移除JavaEE和CORBA模块以及JavaFX</source>
      <description>Java 11 新特性 ：移除JavaEE和CORBA模块以及JavaFX Java 11 中移除了 Java EE 和 CORBA 模块，同时 JavaFX 也被剥离，但仍可作为独立模块使用。 Java9 弃用过程 在 Java 9 中，Java EE 和 CORBA 模块被标记为 @Deprecated，为开发者提供了适应期。 Java11 彻底删除 Java 11 完全删除了以下九个模块：</description>
      <category>Java</category>
      <pubDate>Sun, 24 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java 11 新特性 ：移除JavaEE和CORBA模块以及JavaFX</h1>
<p>Java 11 中移除了 <code>Java EE</code> 和 <code>CORBA</code> 模块，同时 <code>JavaFX</code> 也被剥离，但仍可作为独立模块使用。</p>
<h2> Java9 弃用过程</h2>
<p>在 Java 9 中，<code>Java EE</code> 和 <code>CORBA</code> 模块被标记为 @Deprecated，为开发者提供了适应期。</p>
<h2> Java11 彻底删除</h2>
<p>Java 11 完全删除了以下九个模块：</p>
<ul>
<li>java.xml.ws（包含 JAX-WS、SAAJ 和 Web 服务元数据）</li>
<li>java.xml.bind（JAXB）</li>
<li>java.activation(JAF)</li>
<li>java.xml.ws.annotation（常用注解）</li>
<li>java.corba（CORBA）</li>
<li>java.transaction(JTA)</li>
<li>java.se.ee (以上6个模块的聚合模块)</li>
<li>jdk.xml.ws (JAX-WS 工具)</li>
<li>jdk.xml.bind (JAXB 工具)</li>
</ul>
<p>删除后的影响：</p>
<ul>
<li>源代码从 OpenJDK 存储库中删除</li>
<li>在 JDK 运行时映像中将不包含这些类</li>
<li>相关工具将不再可用:
<ul>
<li>wsgen and wsimport (来自 jdk.xml.ws)</li>
<li>schemagen and xjc (来自 jdk.xml.bind)</li>
<li>idlj, orbd, servertool, and tnamesrv (来自 java.corba)</li>
</ul>
</li>
<li>JNDI CosNaming 提供者 (来自 java.corba) 将不再可用</li>
<li>不再有命令行标志能够启用它们，就像 JDK 9 上的 --add-modules 一样</li>
</ul>
<h2> JavaFX 移除</h2>
<p><code>JavaFX</code> 在 Java 11 中被移除，但仍可以作为独立模块使用。
开发者需要额外的配置和依赖，以在项目中继续使用 JavaFX 技术。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 10 新特性：局部变量类型推断</title>
      <link>https://joeljhou/joeljhou/java-features/Java10/jep286-local-variable-type-inference.html</link>
      <guid>https://joeljhou/joeljhou/java-features/Java10/jep286-local-variable-type-inference.html</guid>
      <source url="https://joeljhou/joeljhou/rss.xml">Java 10 新特性：局部变量类型推断</source>
      <description>Java 10 新特性：局部变量类型推断 Java 10 引入了一项新的语言特性，即局部变量类型推断（Local-Variable Type Inference）， 它允许在局部变量声明时，根据变量的初始值，推断出变量的数据类型。 语法 局部变量类型推断的语法非常简单，只需要将 var 关键字作为局部变量的类型即可。 var list = new ArrayList&amp;lt;String&amp;gt;(); // 自动推断 ArrayList&amp;lt;String&amp;gt; var stream = list.stream(); // 自动推断 Stream&amp;lt;String&amp;gt;</description>
      <category>Java</category>
      <pubDate>Sat, 23 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Java 10 新特性：局部变量类型推断</h1>
<p>Java 10 引入了一项新的语言特性，即局部变量类型推断（Local-Variable Type Inference），
它允许在局部变量声明时，根据变量的初始值，推断出变量的数据类型。</p>
<h2> 语法</h2>
<p>局部变量类型推断的语法非常简单，只需要将 <code>var</code> 关键字作为局部变量的类型即可。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 示例</h2>
<p>相比传统的方式和 Java 7 的钻石操作符（Diamond Operator），Java 10 的局部变量类型推断使得代码更加精炼：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在使用 var 进行局部变量类型推断时，需要注意以下几点：</p>
<ol>
<li>必须在声明的同时进行初始化</li>
<li>仅限于局部变量，不能用于定义成员变量、方法参数和返回类型</li>
<li>每次只能定义一个变量，不能复合声明多个变量</li>
</ol>
<p>通过使用局部变量类型推断，我们能够在不失代码可读性的前提下，减少了冗余的类型声明，使得代码更加简洁清晰。
这一特性尤其在Lambda表达式、集合初始化等场景下表现突出，提高了代码的书写效率。
在实际项目中，合理运用局部变量类型推断，将有助于代码的维护和阅读。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 9-21：前沿特性解读系列（持续连载）</title>
      <link>https://joeljhou/joeljhou/java-features/</link>
      <guid isPermaLink="false">https://joeljhou/joeljhou/java-features/</guid>
      <source url="https://joeljhou/joeljhou/rss.xml">Java 9-21：前沿特性解读系列（持续连载）</source>
      <description>Java 9-21：前沿特性解读系列（持续连载），截至2023年9月中旬，Java已达到第21版本。 尽管如此，众多开发者仍停滞在Java 8的认知水平。为填补这一差距，我们推出专栏，聚焦分享最新Java知识。</description>
      <category>Java</category>
      <pubDate>Wed, 20 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>为了帮助大家跟上最新的技术潮流，计划启动一个专栏，重点分享Java领域的前沿知识。
这个专栏将详细解读从<strong>Java 9 - 最新版本</strong>的各种有趣的新特性。
会持续不断地发布相关内容，希望大家能够关注并收藏起来，跟随我们一起深入了解Java的最新进展！</p>
<p>详细了解Java Enhancement Proposals（JEPs）及其最新动态， 🚀 访问官方网站：<a href="https://openjdk.java.net/jeps/" target="_blank" rel="noopener noreferrer">OpenJDK JEPs</a></p>
<h2> Java 23(in development)</h2>
<h2> Java 22(in development)</h2>
<h2> Java 21(GA 2023/09/19)</h2>
<ul>
<li>430:    String Templates (Preview)</li>
<li>431:    Sequenced Collections</li>
<li>439:    Generational ZGC</li>
<li>440:    Record Patterns</li>
<li>441:    Pattern Matching for switch</li>
<li>442:    Foreign Function &amp; Memory API (Third Preview)</li>
<li>443:    Unnamed Patterns and Variables (Preview)</li>
<li>444:    Virtual Threads</li>
<li>445:    Unnamed Classes and Instance Main Methods (Preview)</li>
<li>446:    Scoped Values (Preview)</li>
<li>448:    Vector API (Sixth Incubator)</li>
<li>449:    Deprecate the Windows 32-bit x86 Port for Removal</li>
<li>451:    Prepare to Disallow the Dynamic Loading of Agents</li>
<li>452:    Key Encapsulation Mechanism API</li>
<li>453:    Structured Concurrency (Preview)</li>
</ul>
<h2> Java 20(GA 2023/03/21)</h2>
<ul>
<li>429:    Scoped Values (Incubator)</li>
<li>432:    Record Patterns (Second Preview)</li>
<li>433:    Pattern Matching for switch (Fourth Preview)</li>
<li>434:    Foreign Function &amp; Memory API (Second Preview)</li>
<li>436:    Virtual Threads (Second Preview)</li>
<li>437:    Structured Concurrency (Second Incubator)</li>
<li>438:    Vector API (Fifth Incubator)</li>
</ul>
<h2> Java 19(GA 2022/09/20)</h2>
<ul>
<li>405:    Record Patterns (Preview)</li>
<li>422:    Linux/RISC-V Port</li>
<li>424:    Foreign Function &amp; Memory API (Preview)</li>
<li>425:    Virtual Threads (Preview)</li>
<li>426:    Vector API (Fourth Incubator)</li>
<li>427:    Pattern Matching for switch (Third Preview)</li>
<li>428:    Structured Concurrency (Incubator)</li>
</ul>
<h2> Java 18(GA 2022/03/22)</h2>
<ul>
<li>400:    UTF-8 by Default</li>
<li>408:    Simple Web Server</li>
<li>413:    Code Snippets in Java API Documentation</li>
<li>416:    Reimplement Core Reflection with Method Handles</li>
<li>417:    Vector API (Third Incubator)</li>
<li>418:    Internet-Address Resolution SPI</li>
<li>419:    Foreign Function &amp; Memory API (Second Incubator)</li>
<li>420:    Pattern Matching for switch (Second Preview)</li>
<li>421:    Deprecate Finalization for Removal</li>
</ul>
<h2> Java 17(GA 2021/09/14)</h2>
<ul>
<li>306:    Restore Always-Strict Floating-Point Semantics</li>
<li>356:    Enhanced Pseudo-Random Number Generators</li>
<li>382:    New macOS Rendering Pipeline</li>
<li>391:    macOS/AArch64 Port</li>
<li>398:    Deprecate the Applet API for Removal</li>
<li>403:    Strongly Encapsulate JDK Internals</li>
<li><a href="java17/jep406-pattern-matching-for-switch-preview">406:    Pattern Matching for switch (Preview)</a></li>
<li>407:    Remove RMI Activation</li>
<li><a href="java17/jep409-sealed-classes">409:    Sealed Classes</a></li>
<li>410:    Remove the Experimental AOT and JIT Compiler</li>
<li>411:    Deprecate the Security Manager for Removal</li>
<li>412:    Foreign Function &amp; Memory API (Incubator)</li>
<li>414:    Vector API (Second Incubator)</li>
<li>415:    Context-Specific Deserialization Filters</li>
</ul>
<h2> Java 16(GA 2021/03/16)</h2>
<ul>
<li>338:    Vector API (Incubator)</li>
<li>347:    Enable C++14 Language Features</li>
<li>357:    Migrate from Mercurial to Git</li>
<li>369:    Migrate to GitHub</li>
<li>376:    ZGC: Concurrent Thread-Stack Processing</li>
<li>380:    Unix-Domain Socket Channels</li>
<li>386:    Alpine Linux Port</li>
<li>387:    Elastic Metaspace</li>
<li>388:    Windows/AArch64 Port</li>
<li>389:    Foreign Linker API (Incubator)</li>
<li>390:    Warnings for Value-Based Classes</li>
<li>392:    Packaging Tool</li>
<li>393:    Foreign-Memory Access API (Third Incubator)</li>
<li><a href="java16/jep394-pattern-matching-for-instanceof">394:    Pattern Matching for instanceof</a></li>
<li><a href="java16/jep395-records">395:    Records</a></li>
<li>396:    Strongly Encapsulate JDK Internals by Default</li>
<li>397:    Sealed Classes (Second Preview)</li>
</ul>
<h2> Java 15(GA 2020/09/15)</h2>
<ul>
<li>339:    Edwards-Curve Digital Signature Algorithm (EdDSA)</li>
<li>360:    Sealed Classes (Preview)</li>
<li><a href="java15/jep371-hidden-classes">371:    Hidden Classes</a></li>
<li>372:    Remove the Nashorn JavaScript Engine</li>
<li>373:    Reimplement the Legacy DatagramSocket API</li>
<li>374:    Disable and Deprecate Biased Locking</li>
<li>375:    Pattern Matching for instanceof (Second Preview)</li>
<li>377:    ZGC: A Scalable Low-Latency Garbage Collector</li>
<li><a href="java15/jep378-text-blocks">378:    Text Blocks</a></li>
<li>379:    Shenandoah: A Low-Pause-Time Garbage Collector</li>
<li>381:    Remove the Solaris and SPARC Ports</li>
<li>383:    Foreign-Memory Access API (Second Incubator)</li>
<li>384:    Records (Second Preview)</li>
<li>385:    Deprecate RMI Activation for Removal</li>
</ul>
<h2> Java 14(GA 2020/03/17)</h2>
<ul>
<li>305:    Pattern Matching for instanceof (Preview)</li>
<li>343:    Packaging Tool (Incubator)</li>
<li>345:    NUMA-Aware Memory Allocation for G1</li>
<li>349:    JFR Event Streaming</li>
<li>352:    Non-Volatile Mapped Byte Buffers</li>
<li>358:    Helpful NullPointerExceptions</li>
<li>359:    Records (Preview)</li>
<li><a href="java14/jep361-switch-expressions">361:    Switch Expressions (Standard)</a></li>
<li>362:    Deprecate the Solaris and SPARC Ports</li>
<li>363:    Remove the Concurrent Mark Sweep (CMS) Garbage Collector</li>
<li>364:    ZGC on macOS</li>
<li>365:    ZGC on Windows</li>
<li>366:    Deprecate the ParallelScavenge + SerialOld GC Combination</li>
<li>367:    Remove the Pack200 Tools and API</li>
<li>368:    Text Blocks (Second Preview)</li>
<li>370:    Foreign-Memory Access API (Incubator)</li>
</ul>
<h2> Java 13(GA 2019/09/17)</h2>
<ul>
<li>350: Dynamic CDS Archives</li>
<li>351: ZGC: Uncommit Unused Memory</li>
<li>353: Reimplement the Legacy Socket API</li>
<li>354: Switch Expressions (Preview)</li>
<li>355: Text Blocks (Preview)</li>
</ul>
<h2> Java 12(GA 2019/03/19)</h2>
<ul>
<li>189: Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)</li>
<li>230: Microbenchmark Suite</li>
<li>325: Switch Expressions (Preview)</li>
<li>334: JVM Constants API</li>
<li>340: One AArch64 Port, Not Two</li>
<li>341: Default CDS Archives</li>
<li>344: Abortable Mixed Collections for G1</li>
<li>346: Promptly Return Unused Committed Memory from G1</li>
</ul>
<h2> Java 11(GA 2018/09/25)</h2>
<ul>
<li>181: Nest-Based Access Control</li>
<li>309: Dynamic Class-File Constants</li>
<li>315: Improve Aarch64 Intrinsics</li>
<li>318: Epsilon: A No-Op Garbage Collector</li>
<li><a href="java11/jep320-remove-JavaEE-CORBA">320: Remove the Java EE and CORBA Modules</a></li>
<li>321: HTTP Client (Standard)</li>
<li>323: Local-Variable Syntax for Lambda Parameters</li>
<li>324: Key Agreement with Curve25519 and Curve448</li>
<li>327: Unicode 10</li>
<li>328: Flight Recorder</li>
<li>329: ChaCha20 and Poly1305 Cryptographic Algorithms</li>
<li>330: Launch Single-File Source-Code Programs</li>
<li>331: Low-Overhead Heap Profiling</li>
<li>332: Transport Layer Security (TLS) 1.3</li>
<li>333: ZGC: A Scalable Low-Latency Garbage Collector(Experimental)</li>
<li>335: Deprecate the Nashorn JavaScript Engine</li>
<li>336: Deprecate the Pack200 Tools and API</li>
</ul>
<h2> Java 10(GA 2018/03/20)</h2>
<ul>
<li><a href="java10/jep286-local-variable-type-inference">286: Local-Variable Type Inference</a></li>
<li>296: Consolidate the JDK Forest into a Single Repository</li>
<li>304: Garbage-Collector Interface</li>
<li>307: Parallel Full GC for G1</li>
<li>310: Application Class-Data Sharing</li>
<li>312: Thread-Local Handshakes</li>
<li>313: Remove the Native-Header Generation Tool (javah)</li>
<li>314: Additional Unicode Language-Tag Extensions</li>
<li>316: Heap Allocation on Alternative Memory Devices</li>
<li>317: Experimental Java-Based JIT Compiler</li>
<li>319: Root Certificates</li>
<li>322: Time-Based Release Versioning</li>
</ul>
<h2> Java 9(GA 2017/09/21)</h2>
<ul>
<li>102: Process API Updates</li>
<li>110: HTTP 2 Client</li>
<li>143: Improve Contended Locking</li>
<li>158: Unified JVM Logging</li>
<li>165: Compiler Control</li>
<li>193: Variable Handles</li>
<li>197: Segmented Code Cache</li>
<li>199: Smart Java Compilation, Phase Two</li>
<li>200: The Modular JDK</li>
<li>201: Modular Source Code</li>
<li>211: Elide Deprecation Warnings on Import Statements</li>
<li>212: Resolve Lint and Doclint Warnings</li>
<li>213: Milling Project Coin</li>
<li>214: Remove GC Combinations Deprecated in JDK 8</li>
<li>215: Tiered Attribution for javac</li>
<li>216: Process Import Statements Correctly</li>
<li>217: Annotations Pipeline 2.0</li>
<li>219: Datagram Transport Layer Security (DTLS)</li>
<li>220: Modular Run-Time Images</li>
<li>221: Simplified Doclet API</li>
<li><a href="java9/jep222-jshell">222: jshell: The Java Shell (Read-Eval-Print Loop)</a></li>
<li>223: New Version-String Scheme</li>
<li>224: HTML5 Javadoc</li>
<li>225: Javadoc Search</li>
<li>226: UTF-8 Property Files</li>
<li>227: Unicode 7.0</li>
<li>228: Add More Diagnostic Commands</li>
<li>229: Create PKCS12 Keystores by Default</li>
<li>231: Remove Launch-Time JRE Version Selection</li>
<li>232: Improve Secure Application Performance</li>
<li>233: Generate Run-Time Compiler Tests Automatically</li>
<li>235: Test Class-File Attributes Generated by javac</li>
<li>236: Parser API for Nashorn</li>
<li>237: Linux/AArch64 Port</li>
<li>238: Multi-Release JAR Files</li>
<li>240: Remove the JVM TI hprof Agent</li>
<li>241: Remove the jhat Tool</li>
<li>243: Java-Level JVM Compiler Interface</li>
<li>244: TLS Application-Layer Protocol Negotiation Extension</li>
<li>245: Validate JVM Command-Line Flag Arguments</li>
<li>246: Leverage CPU Instructions for GHASH and RSA</li>
<li>247: Compile for Older Platform Versions</li>
<li>248: Make G1 the Default Garbage Collector</li>
<li>249: OCSP Stapling for TLS</li>
<li>250: Store Interned Strings in CDS Archives</li>
<li>251: Multi-Resolution Images</li>
<li>252: Use CLDR Locale Data by Default</li>
<li>253: Prepare JavaFX UI Controls &amp; CSS APIs for Modularization</li>
<li>254: Compact Strings</li>
<li>255: Merge Selected Xerces 2.11.0 Updates into JAXP</li>
<li>256: BeanInfo Annotations</li>
<li>257: Update JavaFX/Media to Newer Version of GStreamer</li>
<li>258: HarfBuzz Font-Layout Engine</li>
<li>259: Stack-Walking API</li>
<li>260: Encapsulate Most Internal APIs</li>
<li>261: Module System</li>
<li>262: TIFF Image I/O</li>
<li>263: HiDPI Graphics on Windows and Linux</li>
<li>264: Platform Logging API and Service</li>
<li>265: Marlin Graphics Renderer</li>
<li>266: More Concurrency Updates</li>
<li>267: Unicode 8.0</li>
<li>268: XML Catalogs</li>
<li><a href="Java9/jep269-convenience-factory-methods-for-collections">269: Convenience Factory Methods for Collections</a></li>
<li>270: Reserved Stack Areas for Critical Sections</li>
<li>271: Unified GC Logging</li>
<li>272: Platform-Specific Desktop Features</li>
<li>273: DRBG-Based SecureRandom Implementations</li>
<li>274: Enhanced Method Handles</li>
<li>275: Modular Java Application Packaging</li>
<li>276: Dynamic Linking of Language-Defined Object Models</li>
<li>277: Enhanced Deprecation</li>
<li>278: Additional Tests for Humongous Objects in G1</li>
<li>279: Improve Test-Failure Troubleshooting</li>
<li>280: Indify String Concatenation</li>
<li>281: HotSpot C++ Unit-Test Framework</li>
<li>282: jlink: The Java Linker</li>
<li>283: Enable GTK 3 on Linux</li>
<li>284: New HotSpot Build System</li>
<li>285: Spin-Wait Hints</li>
<li>287: SHA-3 Hash Algorithms</li>
<li>288: Disable SHA-1 Certificates</li>
<li>289: Deprecate the Applet API</li>
<li>290: Filter Incoming Serialization Data</li>
<li>291: Deprecate the Concurrent Mark Sweep (CMS) Garbage Collector</li>
<li>292: Implement Selected ECMAScript 6 Features in Nashorn</li>
<li>294: Linux/s390x Port</li>
<li>295: Ahead-of-Time Compilation</li>
<li>297: Unified arm32/arm64 Port</li>
<li>298: Remove Demos and Samples</li>
<li>299: Reorganize Documentation</li>
</ul>
<h2> Java 8(GA 2014/03/18)</h2>
]]></content:encoded>
    </item>
  </channel>
</rss>