import{_ as a,o as s,c as n,f as e}from"./app-MMGBVa2N.js";const c={},l=e(`<h1 id="java-17-新特性-sealed类" tabindex="-1"><a class="header-anchor" href="#java-17-新特性-sealed类" aria-hidden="true">#</a> Java 17 新特性：sealed类</h1><p>Java 17 中引入了<strong>密封类</strong>（Sealed Classes），它是一种限制的类和接口， 可以控制哪些类继承或实现它，保证在编译时就能够确定类的继承关系，提高代码的可读性和可维护性。</p><h2 id="密封类语法" tabindex="-1"><a class="header-anchor" href="#密封类语法" aria-hidden="true">#</a> 密封类语法</h2><p>密封类的声明使用关键字 <code>sealed</code>，并通过 <code>permits</code> 关键字声明允许继承或实现的类。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 密封类</span>
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> 类名 <span class="token keyword">extends</span> 父类名 <span class="token keyword">permits</span> 子类名<span class="token number">1</span><span class="token punctuation">,</span> 子类名<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">{</span>
  <span class="token comment">// 类的成员</span>
<span class="token punctuation">}</span>

<span class="token comment">// 密封接口</span>
<span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">interface</span> 接口名 <span class="token keyword">extends</span> 父接口名 <span class="token keyword">permits</span> 子类名<span class="token number">1</span><span class="token punctuation">,</span> 子类名<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">{</span>
  <span class="token comment">// 接口的成员</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>密封类对其允许的子类施加了三个约束：</p><ol><li>密封类及其允许的子类必须属于同一个模块或同一包（对于未命名模块）</li><li>每个允许的子类必须直接扩展密封类</li><li>每个允许的子类必须使用修饰符描述其继承关系： <ul><li><code>final</code>：表示该类不能被继承（记录类隐式声明为 <code>final</code>）</li><li><code>sealed</code>：表示该类可以被继承，但只能被允许的子类继承</li><li><code>non-sealed</code>：表示该类可以被继承，且可以被任意类继承</li></ul></li></ol><h2 id="历史限制继承手段" tabindex="-1"><a class="header-anchor" href="#历史限制继承手段" aria-hidden="true">#</a> 历史限制继承手段</h2><p>对于继承能力的限制，Java 语言已经提供了以下几种手段：</p><ol><li><code>final</code>修饰类，这样类就无法被继承了</li><li>构造函数声明为<code>private</code>或<code>package-private</code>，则只能在同一类或同一包中创建该类的子类</li></ol><h2 id="发展脉络" tabindex="-1"><a class="header-anchor" href="#发展脉络" aria-hidden="true">#</a> 发展脉络</h2><p>该功能经历了2个预览版本（JDK 15中的JEP 360、JDK 16中的JEP 397），最终定稿于JDK 17中的JEP 409。</p>`,12),o=[l];function t(p,i){return s(),n("div",null,o)}const r=a(c,[["render",t],["__file","jep409-sealed-classes.html.vue"]]);export{r as default};
